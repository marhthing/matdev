buildEnhancedFFmpegCommand(inputPath, outputPath, resolution, bitrates) {
        const resConfig = this.resolutions[resolution];
        
        // Modern 2025 FFmpeg: Better aspect ratio handling with even dimensions for libx264
        let scaleFilter;
        if (bitrates.compressionMode === 'aggressive') {
            // For aggressive mode, allow slight stretching for size optimization
            scaleFilter = `scale=${resConfig.width}:${resConfig.height}`;
        } else {
            // For other modes, preserve aspect ratio but ensure even dimensions for libx264
            scaleFilter = `scale='min(${resConfig.width},iw)':'min(${resConfig.height},ih)':force_original_aspect_ratio=decrease:force_divisible_by=2`;
        }
        
        // Modern 2025 FFmpeg encoding parameters
        // Use CRF for quality control and modern optimizations
        const crf = this.getCRFForBitrate(bitrates.video, resolution);
        const preset = bitrates.compressionMode === 'aggressive' ? 'faster' : 
                      bitrates.compressionMode === 'high-quality' ? 'slow' : 'medium';
        const tune = bitrates.compressionMode === 'aggressive' ? 'fastdecode' : 'film';
        
        // ðŸ”§ FIXED: Modern 2025 frame rate handling without skipping frames
        // Use fps filter with proper frame blending instead of minterpolate
        let fpsFilter = '';
        
        // Only apply FPS conversion if target differs significantly from source
        // Use tblend for smooth frame rate reduction, duplicate frames for increases
        if (this.targetFPS <= 30) {
            // For 25 FPS target, use advanced temporal blending
            fpsFilter = `,fps=${this.targetFPS}:round=down`;
            // Alternative with motion blur for smoother results:
            // fpsFilter = `,tblend=average,fps=${this.targetFPS}:round=down`;
        } else {
            // For higher target FPS, simple duplication is better
            fpsFilter = `,fps=${this.targetFPS}`;
        }
        
        const combinedFilter = `${scaleFilter}${fpsFilter}`;
        
        // 2025 optimized FFmpeg command with:
        // - CRF-based quality control (modern approach)
        // - Content-aware tuning
        // - High profile with modern level
        // - Psychovisual optimizations
        // - Improved GOP structure
        // - FIXED: Proper frame rate conversion without interpolation artifacts
        return `ffmpeg -i "${inputPath}" ` +
               `-vf "${combinedFilter}" ` +
               `-c:v libx264 ` +
               `-preset ${preset} ` +
               `-crf ${crf} ` +
               `-tune ${tune} ` +
               `-profile:v high ` +
               `-level 4.1 ` +
               `-pix_fmt yuv420p ` +
               `-g 60 ` +
               `-bf 3 ` +
               `-b_strategy 2 ` +
               `-refs 3 ` +
               `-aq-mode 1 ` +
               `-psy-rd 1.0:0.15 ` +
               `-maxrate ${Math.floor(bitrates.video * 1.5)}k ` +
               `-bufsize ${Math.floor(bitrates.video * 3)}k ` +
               `-c:a aac ` +
               `-b:a ${bitrates.audio}k ` +
               `-profile:a aac_low ` +
               `-ac 2 ` +
               `-ar 44100 ` +
               `-movflags +faststart ` +
               `"${outputPath}"`;
    }

    // ðŸ†• NEW: Add method to detect source frame rate for better decisions
    async getVideoInfo(videoPath) {
        return new Promise((resolve, reject) => {
            const command = `ffprobe -v quiet -select_streams v:0 -show_entries stream=r_frame_rate,duration -of csv=p=0 "${videoPath}"`;
            
            exec(command, (error, stdout, stderr) => {
                if (error) {
                    console.error('Error getting video info:', error);
                    resolve({ fps: 30, duration: 0 }); // Fallback values
                } else {
                    const lines = stdout.trim().split('\n');
                    const [fpsStr, durationStr] = lines[0].split(',');
                    
                    // Parse frame rate (handle fractional rates like 30000/1001)
                    let fps = 30; // default
                    if (fpsStr && fpsStr.includes('/')) {
                        const [num, den] = fpsStr.split('/').map(Number);
                        fps = Math.round(num / den);
                    } else if (fpsStr) {
                        fps = Math.round(parseFloat(fpsStr));
                    }
                    
                    const duration = parseFloat(durationStr) || 0;
                    
                    resolve({ fps, duration });
                }
            });
        });
    }

    // ðŸ”§ UPDATED: Enhanced buildFFmpegCommand with source FPS awareness
    async buildSmartFFmpegCommand(inputPath, outputPath, resolution, bitrates) {
        const resConfig = this.resolutions[resolution];
        
        // Get source video information
        const videoInfo = await this.getVideoInfo(inputPath);
        const sourceFPS = videoInfo.fps;
        
        // Modern 2025 FFmpeg: Better aspect ratio handling
        let scaleFilter;
        if (bitrates.compressionMode === 'aggressive') {
            scaleFilter = `scale=${resConfig.width}:${resConfig.height}`;
        } else {
            scaleFilter = `scale='min(${resConfig.width},iw)':'min(${resConfig.height},ih)':force_original_aspect_ratio=decrease:force_divisible_by=2`;
        }
        
        // ðŸŽ¯ SMART FPS CONVERSION - No frame skipping approach
        let fpsFilter = '';
        
        if (Math.abs(sourceFPS - this.targetFPS) > 2) {
            // Significant FPS difference - need conversion
            if (sourceFPS > this.targetFPS) {
                // Reducing FPS - use frame blending for smooth motion
                // This prevents jerky motion from simple frame dropping
                fpsFilter = `,tblend=average,fps=${this.targetFPS}:round=down`;
            } else {
                // Increasing FPS - simple duplication (no interpolation artifacts)
                fpsFilter = `,fps=${this.targetFPS}`;
            }
        } else if (sourceFPS !== this.targetFPS) {
            // Small difference - gentle conversion
            fpsFilter = `,fps=${this.targetFPS}:round=near`;
        }
        // If source is already 25 FPS (or very close), no FPS filter needed
        
        const combinedFilter = fpsFilter ? `${scaleFilter}${fpsFilter}` : scaleFilter;
        
        // Enhanced encoding parameters
        const crf = this.getCRFForBitrate(bitrates.video, resolution);
        const preset = bitrates.compressionMode === 'aggressive' ? 'faster' : 
                      bitrates.compressionMode === 'high-quality' ? 'slow' : 'medium';
        const tune = bitrates.compressionMode === 'aggressive' ? 'fastdecode' : 'film';
        
        return `ffmpeg -i "${inputPath}" ` +
               `-vf "${combinedFilter}" ` +
               `-c:v libx264 ` +
               `-preset ${preset} ` +
               `-crf ${crf} ` +
               `-tune ${tune} ` +
               `-profile:v high ` +
               `-level 4.1 ` +
               `-pix_fmt yuv420p ` +
               `-g 60 ` +
               `-bf 3 ` +
               `-b_strategy 2 ` +
               `-refs 3 ` +
               `-aq-mode 1 ` +
               `-psy-rd 1.0:0.15 ` +
               `-maxrate ${Math.floor(bitrates.video * 1.5)}k ` +
               `-bufsize ${Math.floor(bitrates.video * 3)}k ` +
               `-c:a aac ` +
               `-b:a ${bitrates.audio}k ` +
               `-profile:a aac_low ` +
               `-ac 2 ` +
               `-ar 44100 ` +
               `-movflags +faststart ` +
               `"${outputPath}"`;
    }